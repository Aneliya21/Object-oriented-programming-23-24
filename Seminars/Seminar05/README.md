## Агрегация и композиция
### Композиция
- отношение, при което вътрешния клас (B) няма предназначение в системата извън външния (A)
- A "притежава" B
- А отговаря за жизнения цикъл на B
- комания <- акаунти

```cpp
class A {
    B obj;
}
```
### Агрегация
- отношение, при която вътрешния клас (B) може да съществува независимо от външния (A)
- A "използва" B
- A не отговаря за жизнения цикъл на B
- комания <- хора


```cpp
class A {
    B& obj;
}

//или

class A {
    B* obj;
}

```

![Primer](https://www.google.com/url?sa=i&url=https%3A%2F%2Fwww.cplusoop.com%2Fuml%2Fmodule4%2FmodelingAggregation-composition.php&psig=AOvVaw2FlMqdgsVY1JqHvyjr4E2Z&ust=1711015515273000&source=images&cd=vfe&opi=89978449&ved=0CBIQjRxqFwoTCNi2kNLLgoUDFQAAAAAdAAAAABAQ)


## Разделна компилация
### Препроцесор
- във фазата на предварителна обработка (преди компилацията) се правят различни промени в текста на файла с код
- не променя оригиналните файлове с код - временно в паметта или чрез временни файлове
- премахва коментарите и гарантира, че всеки файл с код завършва с нов ред
- обработва препроцесорните директиви - инструкции, които започват със символа # и завършват с нов ред, НЕ с точка и запетая (имат собтвен синтаксис)
#### Препроцесорни директиви
`#include` 
- препроцесорът заменя директивата със съдържанието на включения файл
- след това включеното съдържание се преработва (което може да доведе до рекурсивна преработка на допълнителни #includes), след което се преработва останалата част от файла

`#define`
- може да се използва за създаване на макрос - правило, което определя как входният текст се преобразува в заместващ изходен текст
- бърз, но не може да се дебъгва

### Компилация
1. Kомпилаторът проверява дали кодът спазва правилата на езика C++. Ако не е така, компилаторът ще даде съобщение за грешка (и съответния номер на реда). Процесът на компилиране също така ще бъде прекъснат, докато грешката не бъде отстранена.

2. Компилаторът превежда кода на C++ в инструкции на машинен език. Тези инструкции се съхраняват в междинен файл, наречен **обектен файл** (с разширение `.obj`)

### Linking
1. Linker-ът прочита всеки от файловете с обекти, генерирани от компилатора, и се уверява, че те са валидни.
2. Linker-ът гарантира, че всички междуфайлови зависимости са разрешени правилно. Например, ако дефинираме нещо в един файл, а след това го използваме в друг, линкерът свързва двата файла заедно. Ако не е в състояние да свърже референцията към нещо с неговата дефиниция, ще се получи грешка на linker-а и процесът на свързване ще се прекъсне.
3. Linker-ът може да свързва и библиотечни файлове. Библиотечният файл е колекция от предварително компилиран код, който е "пакетиран" за повторна употреба в други програми.
4. След като linker-ът завърши свързването на всички обектни файлове и библиотеки, ще получим изпълним файл, който можем да стартирате (разширение `.exe`)

### Разделна компилация
- можем да разбием нашата програма на повече от един изходни файлове (`.cpp`)
- те се компилират независимо един от друг, затова, ако направим промяна само в един от тях, другите не се компилират наново
- ако добавим един `cpp` файл в друг, ще се получи колизия, защото и двата файла се компилират
- осъществяваме връзките между файловете чрез header файлове (`.h`), в който включваме само дефиниции на функции
 <br />

#### Header guards
```cpp
#ifndef SOME_UNIQUE_NAME
#define SOME_UNIQUE_NAME

// your declarations (and certain types of definitions) here

#endif
```
- когато header-ът е #included, препроцесорът проверява дали SOME_UNIQUE_NAME е било дефинирано преди това
- ако включваме header-а за първи път, SOME_UNIQUE_NAME няма да е дефинирано, следователно той дефинира SOME_UNIQUE_NAME и включва съдържанието на файла
- ако header-ът бъде включен отново в същия файл, SOME_UNIQUE_NAME вече ще е дефинирано и съдържанието на хедъра ще бъде игнорирано (благодарение на #ifndef).
- по конвенция се задава пълното име на header-а, изписано с главни букви, като се използва долна черта за разделител (името трябва да е уникално)

```cpp
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

#endif
```
```cpp
#ifndef WAVE_H
#define WAVE_H

#include "square.h"

#endif
```
```cpp
#include "square.h"
#include "wave.h"

int main()
{
    return 0;
}
```
```cpp
#ifndef SQUARE_H
#define SQUARE_H

// съдържанието се включва във файла
int getSquareSides()
{
    return 4;
}

#endif // SQUARE_H

#ifndef WAVE_H 
#define WAVE_H
#ifndef SQUARE_H 
// SQUARE_H вече е дефинирано, затова се игнорира
#define SQUARE_H 

int getSquareSides()
{
    return 4;
}

#endif // SQUARE_H
#endif // WAVE_H

int main()
{
    return 0;
}
```

- `#pragma once` има същата цел като header guards: да се избегне многократното включване на даден хедър файл
- изискваме от компилатора да пази хедъра

## Задачи
**Задача 1.**

**Задача 2.**
Напишете клас, който е за работа със събитие. Събитието се характеризира с име (низ до 20 символа), дата, начален час и краен час.

**Задача 3.**
Напишете клас за работа с колекция от събития (най-много 20). Трябва да имате:
 - Добавяне на събитие.
 - Намиране на най-дългото събитие.
 - Приемане на дата и връщане на максималния брой събития, които може да се посетят в този ден. (за да се посетят 2 събития, те трябва да не се пресичат).
 - Премахване на събитие по име.
