## Член-функции.
- работят с член-данните на обекта
- преобразува се в обикновена функция с уникално име и един допълнителен параметър - **константен указател към обекта**, т.е. можем да променяме обекта,но не и да пренасочвамне указателя
- константни член-функции - константен указател към константен обект, т.е. не можем да променяме член-данните 
- не влияе на размера на структурата

```cpp
struct Test {
    int x = 0;

    void print() const {
        std::cout << "Test";
    }
    void increment() {
        x++;
    }
}

//се преобразува в
void print(const Test* const this) {
    std::cout << "Test";
}
void increment(Test* const this) {
    x++;
}
```

```cpp
int main() {
    Test t;
    t.increment();

    //се преобразува в
    inctrement(&t);
}
```

## Жизнен цикъл на обект. Конструктор и деструктор.
### Жизнен цикъл на обект
1. съдаване
2. използване
3. унищожаване


### Конструктор
- извиква се точно веднъж - при създаване на обекта
- не се оказва експлицитно тип на връщане - връща констатна референция
- заделя се памет и член-данните се инициализират
- вика конструкторите на член-данните си в реда, в който са декларирани
- компилаторът автоматично генерира конструктор по подразбиране - без параметри
- ако се дефинира конструктор с параметри, конструктор по подразбиране **не се генерира**

### Деструктор
- извиква се точно веднъж - при изтриване на обекта
- не се оказва експлицитно тип на връщане
- освобождава паметта, заделена за обекта (за динамични обекти трябва експлицитно да се извика `delete`)
- компилаторът автоматично генерира деструктор

```cpp
#include<iostream>

struct A {
    A() {
        std::cout << "constr of A" << std::endl;
    }

    A(int y) {
        std::cout << "param constr of A" << std::endl;
    }

    ~A() {
        std::cout << "destr of A" << std::endl;
    }
};

struct B {
    int x;
    
    B() {
        std::cout << "constr of B" << std::endl;
    }
    
    B(int y = 0) {
        std::cout << "param constr of B" << std::endl;
        x = y;
    }

    ~B() {
        std::cout << "destr of B" << std::endl;
    }
};

struct C {
    A a;
    B b;
    int x;

    C() : b(1), a(2) {
        std::cout << "Constr of c" << std::endl;
    }

    ~C() {
        std::cout << "destr of C: " << x << std::endl;
    }
};

int main() {
    A* ptr;
    {
        A a;
        ptr = new A;
    }

    B b;
    delete ptr;

    std::cout << std::endl;

    C arr[3];
    for (size_t i = 0; i < 3; i++)
    {
        arr[i].x = i;
    }
}
```

## Капсулация (encapsulation)
- един от основните принципи в ООП
- интерфейс - функции, достатъчни да се работи с даден клас/структура
- имплементация - подробности за това как работи кода - не винаги искаме потребителите да имат достъп до тях 
- искаме да разделим интерфейса от имплементацията
- ограничаването на достъпа ни помага да пазим данните валидни

### Модификатор за достъп
 
| Модификатор за достъп: | Достъп:                         |
|------------------------|---------------------------------|
| private                | В текущия клас.                 |
| protected              | В текущия клас и *наследниците. |
| public                 | За всеки                        |

при **struct** модификаторът за достъп по подразбиране е **public**, а при **class - private**;

## Селектори и мутатори
- публични член-функции които се използват за достъпване (get - селектори) и промяна (set - мутатори) на член-данни, които са декларирани в private/protected секция на един клас

## Задачи

**Задача 1:**
Реализирайте клас/структура интервал, който представлява интервал  [a,b]  (задължително а <= b) от реалната права. Нашият интервал ще бъде дискретен - началото и краят му ще бъдат цели числа и ще разглеждаме само точки, които са цели числа. Релизирайте следният интерфейс:

 - Подразбиращ се контруктор, който създава интервала **[0,0]**.
 - Конструктор, който приема двата параметъра. Ако a<=b, то създава интервала **[a,b]**. В противен случай, създава **[0,0]**.
 - Член-функция, която връща **дължината на интервала**.
 - Член-функция, която приема число и проверява **дали е част от интервала**.
 - Член-функция, която връща **броя на простите числа** в интервала.
 - Член-функция, която връща **броя на числата в интервала**, които са палиндорми.
 - Член-функция, която връща **броя на числата, които нямат повтарящи цифри**.
 - Член-функция, която връща дали началото и края на интервала са **степени на 2-ката**. ([2,16] - истина) 
 - Член-функция, която приема интервал и връща **сечението на текущия интервал с подадения**.  (Сечението на [1, 5]  [3, 7]  e [3, 5]).
 - Член-функция, която приема интервал и връща дали подадения (като параметър) интервал е **подинтервал на текущия**(обектът, от който се извиква функцията).

  **Пример за работа с класа:**
 ```c++

int main()
{
     Interval t1(3,10); // [3, 10]
     Interval t2(4,14); // [4, 14]
     Interval t3; // [0, 0]

     Interval result = t1.intersect(t2); // [4, 10]
     
     t2.isSuperInterval(result); //true
     
     result.calcPrimeNumbersInTheInterval() // 2 (only 5 and 7)
}
 ```

**Задача 2:**

Реализирайте клас **Time**, който ще се използва за работа с часове (13:05:45).
Вашият клас трябва да има следния интерфейс:

 - Подразбиращ се контруктор, който създава часа на **00:00:00**.
 - Конструктор, който приема три параметъра - **час, минути и секунди**.
 - Член-функция, която връща оставащото време до **полунощ**.
 - Член-функция, която увеличава часа с 1 секунда.
 - Член-функция, която връща дали е **време за вечеря**. В рамките на задачата време за вечеря е между **20:30** и **22:00**.
 - Член-функция, която връща дали е **време за парти**. В рамките на задачата време за парти е между **23:00** и **06:00**.
  - Член-функция, която приема друг обект от тип **Time** и връща обект от тип **Time**, което е разликата между двете времена. 
  - Член-функция, която която приема друг обект от тип **Time**  и сравнява двата обекта (по-къснен/по-ранен)
  - Член-функция за принтиране на часа.

Да се направи масив от 10 времена и да се сортира стабилно с някоя от изучаваните сортировки.
