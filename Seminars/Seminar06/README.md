## Голямата четворка (Rule of four)
- ако дефинираме съответните 4 функции, компилаторът ги генерира автоматично
- всяка от тях извиква рекурсивно съответните функции върху член-данните си
### Конструктор по подразбиране <br>
- генерира се автоматично от компулатора, ако **не е дефиниран експлицитно никакъв друг конструктор** (включително копиращ)
- ако е в `private`, не можем да създаваме обекти с него
### Конструктор за копиране <br>
- създава копие на обект
- генерира се от компилатора, ако не е предефиниран
- генерираният автоматично от компилатора к.к. вика рекурсивно конструкторите за копиране на член-данните си в реда, в който са декларирани в класа/структурата
- извиква се при създаване на обект по копие
```cpp
int main() {
    X x1;
    X x2(x1);
    X x3 = x1;
}
```
- и при викане на фукнция, която приема копие на обекта
```cpp
int f(X x) {...}

int main() {
    X x1;
    f(x);
}
```
- важно е да се подава референция, а не копие, защото иначе е получава рекурсивно извикване на к.к., тъй като при подаване по копие се извиква копиращ конструктор

### Оператор за присвояване 
- превръща обект в копие на друг обект
- генерира се от компилатора, ако не е предефиниран
- генерираният автоматично от компилатора oп= вика рекурсивно операторите за присвояване на член-данните си
- извиква се при присвояване на един обект към друг (трябва вече да съществува)
```cpp
int main() {
    X x1;
    X x2;
    x2 = x1;
}
```
- важно е освен да се копира данните, да изтрие тези, които са били вече заделени в паметта
### Деструктор <br>
- генерира се от компилатора, ако не е предефиниран
- ако е в `private`, не могат да се изтриват обекти, следователно не могат и да се създават



## Класове със статична памет
```cpp
class Person {
    char name[26] = "Unknown";
    int age = 18;
public:
    void setName(const char* name) {
        if (name && strlen(name) < 26) {
            strcpy(this->name, name);
        }
    }

    const char* getName() const {
        return name;
    }
};
```

- функциите от голямата четворка не са предефинирани, затова компилаторът ги генерира
- тъй като имаме само статична памет, създаването и изтриването работят коректно
- нямаме указатели (външни ресурси), затова и копирането работи коректно

```cpp
int main()
{
    Person p1;
    Person p2(p1);
    Person p3;
    p3 = p1;

    p1.setName("Ivan");
    std::cout << p1.getName() << std::endl; //Ivan
    std::cout << p2.getName() << std::endl; //Unknown
}
```

## Класове с динамична памет (външни ресурси)
```cpp
class Person {
    char* name = nullptr;
    int age = 18;
public:
    void setName(const char* name) {
        size_t size;
        if (!name || (size = strlen(name)) > 26) {
           return;
        }
        if (this-> name != name) {
            delete[] this->name;
            this->name = new char[size + 1];
            strcpy(this->name, name);
        }
    }

    const char* getName() const {
        return name;
    }
};
```

- тъй като вече имаме динамична памет, генерираният от компилатора деструктор няма да работи коректно, тъй като ще изтрие само данните в стаичната памет, т.е. ще има отечка на памет
- копирането в копиращия конструктор и оператора= няма да работят коректно, тъй като ще копират указателите, т.е. адресите и двата указателя ще сочат на едно и също място 
- ако променим данните през единия, ще се променят данните, към които сочи другият (**shallow copy**)
- затова трябва да предефинираме функциите от голямата четворка (само при композиция!!!)

 ```c++
struct Person
{
	Person(const char* name, int age) {
		setName(name);
		setAge(age);
	}

	Person(const Person& other) {	
		copyFrom(other); // копираме
	}

	Person& operator=(const Person& other) {
		if (this != &other) {
			free(); //трием
			copyFrom(other); //копираме
		}
		return *this;
	}

	~Person() {
		free(); //трием
	}
	
	.
	.
	.
};
```

#### Tрябва да внимаваме кога има нужда да разписваме функциите от голямата четворка
- **НЕ** се разписва голяма четворка при агрегация
- **НЕ** се разписва голяма четворка при указатели към функции
- всеки клас се грижи **само за собствените** си член-данни

```cpp 
class A {
    int* data;
    unsigned size;

    //Big 4
}

class B {
    A a;
}
```
- клас B **не** се грижи за паметта в клас A, клас A трябва сам да се погрижи за собствените си член-данни
- в клас B **НЕ** разписваме голяма четворка, защото генерираните функции от компилатора извикват рекурсивно съответните функции на А, които работят коректно, тъй като сме ги предефинирали в клас А


## Задачи
**Задача 1.** Реализирайте клас Sring, който се използва за работа с низове с произволна дължина.

**Задача 2.**: Напишете клас Set, който съдържа множество от числа (без повторения) в диапазона от 0 до n-1, където n е подадено в началото (1 <= n <= 1000). Класът трябва да пази дали съдържа дадено число в битове, т.е ако съдържа дадено число, съответвеният последователен бит ще бъде 1, в противен случай 0. Пример:

{3, 4, 6} => битове на множеството ще бъдат 00011010

{1, 8, 9} => 01000000 11000000

Класът трябва да има следните функции.

- Добавяне на число
- Проверка дали съдържа число
- Принтиране на всички числа, които съдържа
- Принтиране на това как е представено в паметта
- Член-функция, която приема друго множество и връща тяхното обединение
- Член-функция, която приема друго множество и връща тяхното сечение

**Бонус 1**: Направете класът да не зависи от първоначалното n, тоест по-всяко време да можете да добавите, което и да е число >= 0.

**Бонус 2**: Направете функция, която премахва дадено число от множеството.